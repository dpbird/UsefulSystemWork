\sectionquestion{Computer Science Fundamentals}

\begin{parts}

\part \textbf{Big-O Notation:}
For each pair $(f,g)$ of functions below, select which of the following are true:

\begin{subparts}

\subpart[1] \sone $f(n)=ln(n)$, $g(n)=log_{10}(n)$

\begin{oneparcheckboxes} 
\choice $f(n) = O(g(n))$
\choice $g(n) = O(f(n))$
\choice Both
\choice Neither
\end{oneparcheckboxes}

\begin{soln}
Both
\end{soln}

\subpart[1] \sone $f(n)=\frac{n}{10}, g(n)=log_{10}(n)$

\begin{oneparcheckboxes} 
\choice $f(n) =O(g(n))$
\choice $g(n) =O(f(n))$
\choice Both
\choice Neither
\end{oneparcheckboxes}

\begin{soln}
$g(n)=O(f(n))$
\end{soln}

\subpart[1] \sone $f(n)=n^{50}, g(n)=50^n$

\begin{oneparcheckboxes} 
\choice $f(n) =O(g(n))$
\choice $g(n) =O(f(n))$
\choice Both
\choice Neither
\end{oneparcheckboxes}

\begin{soln}
$f(n)=O(g(n))$
\end{soln}

\end{subparts}

\part[1] What is the average case run time of binary search?

\begin{oneparcheckboxes}
\choice $\Theta(n)$
\choice $\Theta(log(n))$
\choice $\Theta(nlog(n))$
\choice $\Theta(n^2)$
\end{oneparcheckboxes}

\begin{soln}
b. $\Theta(log(n))$
\end{soln}

% \part[1] \sone
% Suppose you are given two positive integers $x$ and $n$, where $x$ is at most $b$ bits. Which of the following is the time complexity of most efficiently computing the exponentiation operation $x^n$, assuming multiplication of $k$-bit numbers takes time $O(k \log k)$?

% \begin{oneparcheckboxes}
% \choice $O(b \log b \log n)$
% \choice $O(bn \log b)$
% \choice $O(bn \log b \log n)$
% \choice $O(bn \log bn \log n)$
% \end{oneparcheckboxes}

% \begin{soln}
% d $O(bn \log bn \log n)$

% NOTE: in S23 none of the answers were correct. This has been updated.
% \end{soln}

\part[1] \sone
Which of these best describes the relationship between a tree data structure and a graph data structure?
\begin{checkboxes}
\choice A graph is a type of tree.
\choice A tree is a type of graph.
\choice It is impossible for a data structure to be both a tree and a graph.
\choice Tree and graph refer to the same concept.
\end{checkboxes}
\begin{soln}
b
\end{soln}

\part[1] \sone
Consider the following function written in Python:
\begin{lstlisting}
def my_fun(x):
    if x == 1:
        return 1
    else:
        return x * my_fun(x - 1) + my_fun(x - 1)
\end{lstlisting}

What is \verb|my_fun(4)|?

\begin{oneparcheckboxes}
\choice 10
\choice 24
\choice 44
\choice 60
\end{oneparcheckboxes}

\begin{soln}
d. 60
\end{soln}

\clearpage

\part
Dave wants to write a function that, given any positive integer $i$, computes the $i^{th}$ Fibonacci number. The $i^{th}$ Fibonacci number $a_i$ is defined as follows:
$$a_i = \begin{cases}
0 & i = 0 \\
1 & i = 1 \\
a_{i - 1} + a_{i - 2} & i > 1 \\
\end{cases}$$

Dave implements the Fibonacci function in Python as follows:

\begin{lstlisting}
def fib(x):
    if x <= 1:
        return x
    else:
        return fib(x - 1) + fib(x - 2)
\end{lstlisting}

\begin{subparts}

\subpart[1] \sone When he tests \verb|fib(100000000)|, his old laptop crashed. Which of these options provides the most likely cause and solution so that Dave's laptop could return the result of \verb|fib(100000000)|?

\begin{checkboxes}
\choice There is a logical error; change line 2 to \verb|if x == 0 or x == 1|.
\choice There is a logical error; only one recursive call can be made in a function body.
\choice The laptop is crashing because it is out of memory due to too many recursive calls; implement a non-recursive version of the function.
\end{checkboxes}
\begin{soln}
c (laptop is crashing because it is out of memory due to too many recursive calls)
\end{soln}

\subpart \textbf{Fill in the blanks:} 
Dave decided to rewrite Fibonacci using bottom-up dynamic programming (DP).
Below, fill in each blank with one line of Python code to yield a correct bottom-up DP implementation.

\begin{lstlisting}[mathescape=true]
def fib_dp(n):
    table = {$\blankforFITB{2em}{i.}$}
    for i in range($\blankforFITB{2em}{ii.}$, $\blankforFITB{2em}{iii.}$):
        $\blankforFITB{4em}{iv.}$
    return table[n]
\end{lstlisting}

\begin{subsubparts}

\subsubpart[1]  \begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
%solution
\end{tcolorbox}

\subsubpart[1]  \begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
%solution
\end{tcolorbox}

\subsubpart[1]  \begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
%solution
\end{tcolorbox}

\subsubpart[1]  \begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
%solution
\end{tcolorbox}

\end{subsubparts}

\begin{soln}
\begin{lstlisting}
{0:0, 1:1}
range(2, n+1)
table[i] = table[i - 1] + table[i - 2]
\end{lstlisting}
\end{soln}

\end{subparts}

\part \textbf{Fill in the blanks:}
Below is a binary search tree class and a partial implementation of an insert function written in Python. Fill in each blank with one line of Python so that \lstinline{insert(value, root)} correctly inserts \lstinline{value} into the correct location of the binary search tree rooted at \lstinline{root}.

\begin{lstlisting}[mathescape=true]
class TNode:
    def __init__(x):
        self.value = x
        self.left = None
        self.right = None


def insert (value, node):
    if $\blankforFITB{2em}{(a)}$ :
        return $\blankforFITB{2em}{(b)}$
    if value < node.value:
        $\blankforFITB{4em}{(c)}$
    elif value > node.value:
        $\blankforFITB{4em}{(d)}$
    return node

# usage: root = insert(value, root)
\end{lstlisting}

\begin{subparts}

\subpart[1]
\begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
% solution
\end{tcolorbox}

\subpart[1]
\begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
%solution
\end{tcolorbox}

\subpart[1]
\begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
%solution
\end{tcolorbox}

\subpart[1]
\begin{tcolorbox}[fit,height=1cm, width=12cm, blank, borderline={1pt}{-2pt}]
%solution
\end{tcolorbox}


\end{subparts}

\begin{soln}
\begin{lstlisting}
(a) node == None / node is None # (both work)
(b) TNode(value) # (also any correct call to the constructor should work)
(c) node.left = insert(value, node.left)
(d) node.right = insert(value, node.right)    
\end{lstlisting}
\end{soln}

\end{parts}
